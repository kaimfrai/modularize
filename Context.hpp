#pragma once

#include "Directory.hpp"

#include <filesystem>
#include <string>

namespace
	Modularize
{
	auto inline
	(	IsHeader
	)	(	::std::filesystem::path const
			&	i_rPath
		)
	->	bool
	{
		::std::string_view const
			vFileName
		=	i_rPath.filename
			().c_str()
		;

		return
		(	vFileName.ends_with(".hpp")
		);
	}

	auto inline
	(	IsImplementation
	)	(	::std::filesystem::path const
			&	i_rPath
		)
	->	bool
	{
		::std::string_view const
			vFileName
		=	i_rPath.filename
			().c_str()
		;

		return
			vFileName.ends_with(".cpp")
		and	// files generated by CMAKE
			vFileName != "CMakeCXXCompilerId.cpp"
		;
	}

	auto inline
	(	IsDependency
	)	(	::std::filesystem::path const
			&	i_rPath
		)
	->	bool
	{
		::std::string const
			vFileName
		=	i_rPath.filename
			()
		;
		return
		vFileName.ends_with
		(	".o.d"
		);
	}

	class
		Context
	{
		Directory
			m_vSourceDirectory
		;
		Directory
			m_vBinaryDirectory
		;
	public:
		explicit(true) inline
		(	Context
		)	(	Directory
					i_vSourceDirectory
			,	Directory
					i_vBinaryDirectory
			)
		:	m_vSourceDirectory
			{	::std::move(i_vSourceDirectory)
			}
		,	m_vBinaryDirectory
			{	::std::move(i_vBinaryDirectory)
			}
		{}

		[[nodiscard]]
		auto inline
		(	GetSourceDirectory
		)	()	const&
		->	Directory const&
		{	return m_vSourceDirectory;	}

		[[nodiscard]]
		auto inline
		(	GetBinaryDirectory
		)	()	const&
		->	Directory const&
		{	return m_vBinaryDirectory;	}

		[[nodiscard]]
		auto inline
		(	StandardLog
		)	()	const
		->	DirectoryRelativeStream<decltype(::std::cerr)>
		{	return
			DirectoryRelativeStream
			{	m_vSourceDirectory
			,	::std::cerr
			};
		}

		[[nodiscard]]
		auto inline
		(	ErrorLog
		)	()	const
		->	DirectoryRelativeStream<decltype(::std::cerr)>
		{	return
			DirectoryRelativeStream
			{	m_vSourceDirectory
			,	::std::cerr
			};
		}
	};
}
